08.08

关于尺度校准：
方案 A｜先把 Uco 做成米制，消灭尺度不一致
最稳的路径：直接用 ArUco **真实边长（米）**与相机标定，让 UcoSLAM 输出米制位姿（很多实现默认就是米制，只要你把 marker_size 配对）。

验证：在静止环境量两点间距离，‖p_uco(i)-p_uco(j)‖ 是否接近实测值。若通过，这条路最干净：Tuco 与 Tlio 不再有尺度问题，直接用 r=log(Tuco⁻¹ Tlio)。

方案 B｜一次性/缓变的 Sim(3) 外参，不逐帧吸收噪声
视 Uco 为“相似变换坐标系”，做一个 全局 Sim(3) 配准：
收集一小段时间窗口内的对应增量 {Δp_uco(k), Δp_lio(k)}，用 Umeyama/Procrustes 算出 (ŝ, R̂, t̂) 使
R̂ (ŝ·Δp_uco) ≈ Δp_lio 最小二乘。

之后在残差计算前固定地做：T̃_uco = (ŝ,R̂,t̂) ∘ Tuco ∘ (ŝ,R̂,t̂)^{-1}（或只用 t' = ŝ·t_uco 与 R_uco）。

若担心漂移，让 (ŝ, R̂, t̂) 慢更新（滑窗/EMA），但不要逐帧用当前残差改它。这样噪声不会被“吸”进 scale。

方案 C｜把尺度当成显式状态，走 Sim(3) 残差
在 EKF 里扩一维 α = log s（或者单独维护一个 s，但推荐 α），观测模型用 Sim(3)：
e = (S_uco(α))^{-1} ∘ S_lio，r = log(e) ∈ R^7（或仍用 6 维，只在内部用 s 放大平移：t_uco' = s·t_uco）。

关键点：对 α 的雅可比别手写复杂解析，继续用数值差分最省心：
α → α ± ε，重算 r，H_α = (r+ − r−)/(2ε)。

给 α 一个弱先验（比如 α ~ N(0, σ_α^2)），以及马氏门限对整条 6/7 维观测做 gating，避免坏观测把 α 拉飞。

好处：尺度由滤波器“看数据”自己估，不会把当次创新硬吃进 scale，同时保留了 R 与 t 在 log 映射里的自然耦合。


实操细节与防坑
不要逐帧用 scale = ‖Δp_lio‖/‖Δp_uco‖；至少用 滑窗中位数/Huber 权：
ŝ = median_k ( ‖Δp_lio(k)‖ / ‖Δp_uco(k)‖ )，配合 创新门限剔除异常帧。

拉大基线：用 N 帧相对位姿（k−N→k），减少瞬时噪声对比值的影响。

R 不吃尺度：即便在 Sim(3)，尺度与旋转是并行分量；耦合只通过 log 的线性化进入残差，不要人工把 s“映射到 R”。

数值雅可比：你现在对位姿 6 维做中心差分非常好；若加 α，就 7 维一起差。保持 ε=1e−6 量级并加门限即可。

权重自适应：按 Uco 跟踪状态（GOOD/OK/LOST）调 R；尺度 α 的过程噪声设小点，防止抖动。

快速决策建议（按优先级）
能做就做 A：核对并修正 UcoSLAM 的 marker 尺寸与内参，让 Tuco 直接米制。

若短期改 Uco 不方便：先上 B（静态 Sim(3)），一段时间估一次，锁定使用。

需要在线自适应：再上 C（把 α=log s 纳入观测/状态），仍用数值雅可比与创新门限。

一句话总结：尺度是独立自由度，别用“逐帧平移比”去吞噪声；要么把 Uco 做成米制，要么用（缓变的）Sim(3) 把尺度“前置”对齐，要么把尺度纳入估计并用滤波器去学它。这样融合才既稳又干净。



----------------------------------------------------------------------------------------------

你这个随笔很对：逐帧用“长度比”做动态 scale，无论是一维、三维平均，还是用二范数，都会不同程度把“当次噪声/创新”吞进 scale，从而稀释了残差。如果又用这个“被噪声污染的 scale”去构残差，EKF 的创新就被你先处理掉一部分——这就是你说的悖论。

下面给你一个不吸残差、又不偏袒坐标轴的做法（结论先行）：

结论（首选）
用各向同性单一尺度 
𝑠
s 的滑窗最小二乘，且对当前帧留一（不把本帧数据用于估计 
𝑠
s）：

𝑠
\*
=
arg
⁡
min
⁡
𝑠
∑
𝑘
∈
𝑊
past
𝑤
𝑘
 
∥
 
𝑠
 
Δ
𝑝
𝑘
 
uco
−
Δ
𝑝
𝑘
 
lio
∥
2
⇒
𝑠
\*
=
∑
𝑤
𝑘
 
Δ
𝑝
𝑘
 
uco
⋅
Δ
𝑝
𝑘
 
lio
∑
𝑤
𝑘
 
∥
Δ
𝑝
𝑘
 
uco
∥
2
s 
\*
 =arg 
s
min
​
  
k∈W 
past
​
 
∑
​
 w 
k
​
  ∥sΔp 
k
uco
​
 −Δp 
k
lio
​
 ∥ 
2
 ⇒s 
\*
 = 
∑w 
k
​
  ∥Δp 
k
uco
​
 ∥ 
2
 
∑w 
k
​
  Δp 
k
uco
​
 ⋅Δp 
k
lio
​
 
​
 
性质：旋转不变（不偏袒任何轴），不会像“分量平均/分量比”那样受坐标系选择影响。

不吃创新：
𝑊
past
W 
past
​
  只用过去 
𝑁
N 帧（或上一段时间），当前帧的 
Δ
𝑝
Δp 不参与 
𝑠
s 估计，避免把本轮创新吸到 
𝑠
s 里。

鲁棒：设置权重 
𝑤
𝑘
w 
k
​
  为 Huber/卡方门限后的权（按 
∥
 
Δ
𝑝
𝑘
lio
−
𝑠
 
Δ
𝑝
𝑘
uco
∥
∥Δp 
k
lio
​
 −sΔp 
k
uco
​
 ∥ 或按两者夹角），并丢弃小基线帧（
∥
Δ
𝑝
𝑘
uco
∥
<
𝜏
∥Δp 
k
uco
​
 ∥<τ）。

实现：得到 
𝑠
\*
s 
\*
  后，仅 缩放平移：
𝑡
uco
′
=
𝑠
\*
 
𝑡
uco
t 
uco
′
​
 =s 
\*
 t 
uco
​
 ，不要对 
𝑅
R 做任何“映射”；然后照旧算 
𝑟
=
log
⁡
(
(
𝑅
uco
,
𝑡
uco
′
)
−
1
(
𝑅
lio
,
𝑡
lio
)
)
r=log((R 
uco
​
 ,t 
uco
′
​
 ) 
−1
 (R 
lio
​
 ,t 
lio
​
 ))。

为何不做“分量平均/分量二范数比”？

分量平均/分量比 ⇒ 暗含各向异性标定（类似对角缩放 
d
i
a
g
(
𝑠
𝑥
,
𝑠
𝑦
,
𝑠
𝑧
)
diag(s 
x
​
 ,s 
y
​
 ,s 
z
​
 )），与“真实世界各向同性尺度”不符，还会受坐标旋转影响。

二范数逐帧比 ⇒ 最容易把当帧噪声吃进 
𝑠
s。

工程要点（短平快）
留一 + 滑窗：当前帧残差用 
𝑠
\*
s 
\*
 （由“上一窗”产出）。可用 EMA（
𝛼
∈
[
0.9
,
0.99
]
α∈[0.9,0.99]）平滑 
𝑠
s。

基线门限：
min
⁡
∥
Δ
𝑝
𝑘
uco
∥
>
𝜏
min∥Δp 
k
uco
​
 ∥>τ（如 3–5 cm）；纯旋转段暂停更新 
𝑠
s。

正值约束：
𝑠
\*
←
max
⁡
(
𝜖
,
𝑠
\*
)
s 
\*
 ←max(ϵ,s 
\*
 )。若出现负值，说明匹配方向系统性反向，需先对齐外参/位姿方向。

创新门限：算完 
𝑟
r 做马氏门限（例如阈值 3–3.5），不合格只预测不更新。

长期最优：若允许，改成 **Sim(3) 滑窗配准（Umeyama）**求 
(
𝑠
^
,
𝑅
^
,
𝑡
^
)
( 
s
^
 , 
R
^
 , 
t
^
 ) 但保持 
𝑅
R 仅用于坐标对齐，不“映射旋转”。

极简伪码
cpp
复制
编辑
// 收集过去 N 帧位移对 (Δp_uco, Δp_lio) —— 不含当前帧
double num=0, den=0;
for (auto& k : window_past) {
  if (norm(dp_uco[k]) < baseline_thresh) continue;
  double w = huber_weight( norm(dp_lio[k] - s_prev*dp_uco[k]) );
  num += w * dp_uco[k].dot(dp_lio[k]);
  den += w * dp_uco[k].squaredNorm();
}
double s_hat = (den > eps) ? std::max(very_small, num/den) : s_prev;
double s_used = ema(alpha=0.95, prev=s_prev, curr=s_hat);

// 用 s_used 只缩放 t_uco，R 不动
t_uco_scaled = s_used * t_uco_raw;
// 然后照常：r = log( (R_uco,t_uco_scaled)^{-1} (R_lio,t_lio) )
何时用“把尺度纳入估计”？
如果你希望 
𝑠
s 自适应又不想维护外部滑窗，可在 EKF 里加 
𝛼
=
log
⁡
𝑠
α=logs 一维状态（或观测参数），仍用数值雅可比对 
𝛼
α 做中心差分；给 
𝛼
α 小过程噪声 + 创新门限。这比逐帧长度比靠谱太多，而且不会吞掉本轮创新。

一句话：尺度是独立自由度，应以各向同性、留一的滑窗 LS（或 EKF 显式状态）去估；不要逐帧用长度比（无论分量、平均还是二范数）来硬对齐，更不要把尺度“映射到旋转”。









询问 ChatGPT

